# Azure DevOps Pipeline for React E-Cart Application
# Following Azure DevOps best practices for CI/CD

trigger:
  branches:
    include:
      - main
      - develop
      - feature/*
  paths:
    exclude:
      - README.md
      - docs/*

pr:
  branches:
    include:
      - main
      - develop
  paths:
    exclude:
      - README.md
      - docs/*

variables:
  # Build Variables
  - name: nodeVersion
    value: '20.x'
  - name: dockerRegistryServiceConnection
    value: 'docker-registry-connection'
  - name: imageRepository
    value: 'react-ekart'
  - name: containerRegistry
    value: 'your-registry.azurecr.io'
  - name: dockerfilePath
    value: '$(Build.SourcesDirectory)/Dockerfile'
  - name: tag
    value: '$(Build.BuildId)'
  
  # Security and Quality Gates
  - name: sonarQubeServiceConnection
    value: 'sonarqube-connection'
  - name: sonarQubeProjectKey
    value: 'react-ekart-project'

stages:
  # Stage 1: Code Quality and Security
  - stage: CodeQuality
    displayName: 'Code Quality & Security Analysis'
    jobs:
      - job: StaticAnalysis
        displayName: 'Static Code Analysis'
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - task: NodeTool@0
            displayName: 'Install Node.js'
            inputs:
              versionSpec: $(nodeVersion)

          - task: Cache@2
            displayName: 'Cache npm dependencies'
            inputs:
              key: 'npm | "$(Agent.OS)" | package-lock.json'
              restoreKeys: |
                npm | "$(Agent.OS)"
                npm
              path: ~/.npm

          - script: |
              npm ci
            displayName: 'Install dependencies'

          - script: |
              npm run lint:check
            displayName: 'Run ESLint'
            continueOnError: true

          - script: |
              npm run type-check
            displayName: 'TypeScript type checking'

          - task: SonarQubePrepare@5
            displayName: 'Prepare SonarQube analysis'
            inputs:
              SonarQube: $(sonarQubeServiceConnection)
              scannerMode: 'CLI'
              configMode: 'manual'
              cliProjectKey: $(sonarQubeProjectKey)
              cliProjectName: 'React E-Cart Application'
              cliSources: 'src'
              extraProperties: |
                sonar.javascript.lcov.reportPaths=coverage/lcov.info
                sonar.typescript.lcov.reportPaths=coverage/lcov.info
                sonar.exclusions=**/*.test.ts,**/*.test.tsx,**/node_modules/**

          - script: |
              npm run test:coverage
            displayName: 'Run unit tests with coverage'

          - task: PublishTestResults@2
            displayName: 'Publish test results'
            inputs:
              testResultsFormat: 'JUnit'
              testResultsFiles: 'coverage/junit.xml'
              failTaskOnFailedTests: true

          - task: PublishCodeCoverageResults@2
            displayName: 'Publish code coverage'
            inputs:
              summaryFileLocation: 'coverage/cobertura-coverage.xml'
              reportDirectory: 'coverage/lcov-report'

          - task: SonarQubeAnalyze@5
            displayName: 'Run SonarQube analysis'

          - task: SonarQubePublish@5
            displayName: 'Publish SonarQube results'
            inputs:
              pollingTimeoutSec: '300'

  # Stage 2: Build and Test
  - stage: BuildAndTest
    displayName: 'Build & Test Application'
    dependsOn: CodeQuality
    condition: succeeded()
    jobs:
      - job: Build
        displayName: 'Build Application'
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - task: NodeTool@0
            displayName: 'Install Node.js'
            inputs:
              versionSpec: $(nodeVersion)

          - task: Cache@2
            displayName: 'Cache npm dependencies'
            inputs:
              key: 'npm | "$(Agent.OS)" | package-lock.json'
              restoreKeys: |
                npm | "$(Agent.OS)"
                npm
              path: ~/.npm

          - script: |
              npm ci
            displayName: 'Install dependencies'

          - script: |
              npm run build
            displayName: 'Build application'

          - task: PublishPipelineArtifact@1
            displayName: 'Publish build artifacts'
            inputs:
              targetPath: 'dist'
              artifactName: 'build-artifacts'
              artifactType: 'pipeline'

      - job: E2ETests
        displayName: 'End-to-End Tests'
        dependsOn: Build
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - task: NodeTool@0
            displayName: 'Install Node.js'
            inputs:
              versionSpec: $(nodeVersion)

          - script: |
              npm ci
            displayName: 'Install dependencies'

          - script: |
              npx playwright install --with-deps
            displayName: 'Install Playwright browsers'

          - script: |
              npm run build
              npm run preview &
              sleep 10
              npm run test:e2e
            displayName: 'Run E2E tests'

          - task: PublishTestResults@2
            displayName: 'Publish E2E test results'
            condition: always()
            inputs:
              testResultsFormat: 'JUnit'
              testResultsFiles: 'playwright-report/results.xml'

  # Stage 3: Security Scanning
  - stage: SecurityScan
    displayName: 'Security Scanning'
    dependsOn: BuildAndTest
    condition: succeeded()
    jobs:
      - job: SecurityAnalysis
        displayName: 'Security Analysis'
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - task: NodeTool@0
            displayName: 'Install Node.js'
            inputs:
              versionSpec: $(nodeVersion)

          - script: |
              npm ci
            displayName: 'Install dependencies'

          - script: |
              npm audit --audit-level=high
            displayName: 'Run npm security audit'
            continueOnError: true

          - task: CmdLine@2
            displayName: 'Run Snyk security scan'
            inputs:
              script: |
                npm install -g snyk
                snyk auth $SNYK_TOKEN
                snyk test --severity-threshold=high
            env:
              SNYK_TOKEN: $(SNYK_TOKEN)
            continueOnError: true

  # Stage 4: Docker Build and Push
  - stage: DockerBuildPush
    displayName: 'Docker Build & Push'
    dependsOn: 
      - BuildAndTest
      - SecurityScan
    condition: and(succeeded(), or(eq(variables['Build.SourceBranch'], 'refs/heads/main'), eq(variables['Build.SourceBranch'], 'refs/heads/develop')))
    jobs:
      - job: DockerBuild
        displayName: 'Build and Push Docker Image'
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - task: Docker@2
            displayName: 'Build Docker image'
            inputs:
              command: 'build'
              repository: $(imageRepository)
              dockerfile: $(dockerfilePath)
              tags: |
                $(tag)
                latest
              arguments: '--build-arg BUILD_DATE=$(Build.BuildId) --build-arg VCS_REF=$(Build.SourceVersion)'

          - task: Docker@2
            displayName: 'Push Docker image to registry'
            inputs:
              command: 'push'
              repository: $(imageRepository)
              containerRegistry: $(dockerRegistryServiceConnection)
              tags: |
                $(tag)
                latest

          - task: CmdLine@2
            displayName: 'Run Trivy security scan on Docker image'
            inputs:
              script: |
                sudo apt-get update
                sudo apt-get install wget apt-transport-https gnupg lsb-release
                wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add -
                echo "deb https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main" | sudo tee -a /etc/apt/sources.list.d/trivy.list
                sudo apt-get update
                sudo apt-get install trivy
                trivy image --exit-code 1 --severity HIGH,CRITICAL $(imageRepository):$(tag)
            continueOnError: true

  # Stage 5: Deployment (Production)
  - stage: DeployProduction
    displayName: 'Deploy to Production'
    dependsOn: DockerBuildPush
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
    jobs:
      - deployment: DeployToProduction
        displayName: 'Deploy to Production Environment'
        environment: 'production'
        pool:
          vmImage: 'ubuntu-latest'
        strategy:
          runOnce:
            deploy:
              steps:
                - task: AzureWebAppContainer@1
                  displayName: 'Deploy to Azure Web App'
                  inputs:
                    azureSubscription: 'azure-service-connection'
                    appName: 'react-ekart-prod'
                    imageName: '$(containerRegistry)/$(imageRepository):$(tag)'

                - task: AzureCLI@2
                  displayName: 'Run smoke tests'
                  inputs:
                    azureSubscription: 'azure-service-connection'
                    scriptType: 'bash'
                    scriptLocation: 'inlineScript'
                    inlineScript: |
                      # Wait for deployment to be ready
                      sleep 30
                      
                      # Run basic health check
                      response=$(curl -s -o /dev/null -w "%{http_code}" https://react-ekart-prod.azurewebsites.net)
                      if [ $response -eq 200 ]; then
                        echo "Smoke test passed: Application is healthy"
                      else
                        echo "Smoke test failed: HTTP $response"
                        exit 1
                      fi

  # Stage 6: Deployment (Staging)
  - stage: DeployStaging
    displayName: 'Deploy to Staging'
    dependsOn: DockerBuildPush
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/develop'))
    jobs:
      - deployment: DeployToStaging
        displayName: 'Deploy to Staging Environment'
        environment: 'staging'
        pool:
          vmImage: 'ubuntu-latest'
        strategy:
          runOnce:
            deploy:
              steps:
                - task: AzureWebAppContainer@1
                  displayName: 'Deploy to Azure Web App (Staging)'
                  inputs:
                    azureSubscription: 'azure-service-connection'
                    appName: 'react-ekart-staging'
                    imageName: '$(containerRegistry)/$(imageRepository):$(tag)'